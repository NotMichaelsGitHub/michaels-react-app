import { arc } from 'd3-shape';
import shallowEqual from 'shallowequal';
import { createContext, useRef, useState, useEffect, createElement, useContext } from 'react';
import roughjs from 'roughjs/dist/rough.umd';

var isEqual = function (depsA, depsB) {
  if ( depsA === void 0 ) depsA = [];
  if ( depsB === void 0 ) depsB = [];

  if (depsA.length !== depsB.length) {
    return false;
  }

  return depsA.every(function (a, index) { return shallowEqual(a, depsB[index]); });
};

var useShallowEqual = function (f, deps) {
  var ref = useRef([]);

  if (!isEqual(ref.current, deps)) {
    ref.current = deps;
  }

  useEffect(f, ref.current);
};

var Context = createContext(null);

var loopHandlers = function (node, fName, handlers) {
  Object.keys(handlers).forEach(function (name) {
    var eventName = name.replace('on', '').toLowerCase();
    node[fName](eventName, handlers[name]);
  });
};

/* eslint-disable no-case-declarations */
function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

var createSvgNode = function (tagName, attributes) {
  var common = {
    opacity: '0',
    fill: 'black',
    stroke: 'black'
  };
  var attrs = Object.assign({}, common,
    attributes);
  var nsString = 'http://www.w3.org/2000/svg';
  var newTagName = tagName;

  if (tagName === 'arc') {
    newTagName = 'path';
    var arc$$1 = arc();
    var innerRadius = attrs.innerRadius;
    var outerRadius = attrs.outerRadius;
    var startAngle = attrs.startAngle;
    var endAngle = attrs.endAngle;
    var x = attrs.x;
    var y = attrs.y;
    var rest$1 = objectWithoutProperties( attrs, ["innerRadius", "outerRadius", "startAngle", "endAngle", "x", "y"] );
    var rest = rest$1;
    var d = arc$$1({
      innerRadius: innerRadius || 0,
      outerRadius: outerRadius || 0,
      startAngle: startAngle || 0,
      endAngle: endAngle || 0
    });
    attrs = Object.assign({}, attrs,
      rest,
      {d: d,
      transform: ("translate(" + x + ", " + y + ")")});
  }

  var node = document.createElementNS(nsString, newTagName);
  Object.keys(attrs).forEach(function (attrName) {
    node.setAttribute(attrName, attrs[attrName]);
  });
  return node;
};

function useDrawEffect(drawFnName, deps, props) {
  if ( props === void 0 ) props = {};

  var value = useContext(Context);
  var nodeRef = useRef(null);
  var fakeNodeRef = useRef(null);

  if (!value) {
    throw Error('Wrap Component inside <RoughProvider>');
  }

  var creteFakeNode = function () {
    var ref;

    switch (drawFnName) {
      case 'rectangle':
        return createSvgNode('rect', {
          x: deps[0],
          y: deps[1],
          width: deps[2],
          height: deps[3]
        });

      case 'path':
        var pathOptions = deps[1] || {};
        return createSvgNode('path', {
          d: deps[0],
          fill: pathOptions.fill ? 'black' : 'none'
        });

      default:
        var options = deps[deps.length - 1] || {};
        var newOptions = Object.assign({}, options,
          {fill: 'black',
          fillStyle: 'solid'});
        var args = deps.slice(0, deps.length - 1).concat( [newOptions]);
        var node = (ref = value.rough)[drawFnName].apply(ref, args);
        node.setAttribute('opacity', '0');
        return node;
    }
  };

  var transform = props.transform;
  var opacity = props.opacity;
  var onClick = props.onClick;
  var onMouseOut = props.onMouseOut;
  var onMouseOver = props.onMouseOver;
  var cursor = props.cursor;
  var strokeDasharray = props.strokeDasharray;
  var onMouseMove = props.onMouseMove;
  var handlers = {
    onClick: onClick,
    onMouseOut: onMouseOut,
    onMouseOver: onMouseOver,
    onMouseMove: onMouseMove
  };

  var setAttribute = function (node, attrs) {
    Object.keys(attrs).forEach(function (attrName) {
      if (attrName === 'strokeDasharray') {
        node.setAttribute('stroke-dasharray', attrs[attrName]);
        return;
      }

      if (attrs[attrName] !== undefined) {
        node.setAttribute(attrName, attrs[attrName]);
      }
    });
  }; // Style Effect


  useEffect(function () {
    if (nodeRef.current) {
      setAttribute(nodeRef.current, {
        transform: transform,
        opacity: opacity,
        cursor: cursor,
        strokeDasharray: strokeDasharray
      });
    }

    if (fakeNodeRef.current) {
      setAttribute(fakeNodeRef.current, {
        transform: transform
      });
    }
  }, [transform, opacity, cursor, strokeDasharray]);
  useShallowEqual(function () {
    var ref;

    if (value.root) {
      var node = (ref = value.rough)[drawFnName].apply(ref, deps);
      nodeRef.current = node;
      var fakeNode = creteFakeNode();
      fakeNodeRef.current = fakeNode;
      setAttribute(node, {
        transform: transform,
        opacity: opacity,
        cursor: cursor,
        strokeDasharray: strokeDasharray
      }); // NOTE node will be last child of its parent. Will cause some shadowing issues

      value.root.appendChild(node);

      if (fakeNode) {
        loopHandlers(fakeNode, 'addEventListener', handlers);
        setAttribute(fakeNode, {
          transform: transform,
          cursor: cursor
        });
        value.root.appendChild(fakeNode);
      } else {
        loopHandlers(node, 'addEventListener', handlers);
      }

      return function () {
        nodeRef.current = null;
        value.root.removeChild(node);

        if (fakeNode) {
          fakeNodeRef.current = null;
          loopHandlers(fakeNode, 'removeEventListener', handlers);
          value.root.removeChild(fakeNode);
        } else {
          loopHandlers(node, 'removeEventListener', handlers);
        }
      };
    }

    return function () {};
  }, [value.root ].concat( deps));
  return value;
}

var Arc = function (props) {
  useDrawEffect('arc', [props.x, props.y, props.width, props.height, props.start, props.stop, props.closed, props.options], props);
  return null;
};
Arc.displayName = 'Arc';
Arc.defaultProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  start: 0,
  stop: Math.PI / 2,
  closed: false
};

var Circle = function (props) {
  useDrawEffect('circle', [props.x, props.y, props.diameter, props.options], props);
  return null;
};
Circle.displayName = 'Circle';
Circle.defaultProps = {
  x: 0,
  y: 0,
  diameter: 0
};

var Curve = function (props) {
  useDrawEffect('curve', [props.points, props.options], props);
  return null;
};
Curve.displayName = 'Curve';
Curve.defaultProps = {
  points: [[0, 0]]
};

var Ellipse = function (props) {
  var x = props.x;
  var y = props.y;
  var width = props.width;
  var height = props.height;
  var options = props.options;
  useDrawEffect('ellipse', [x, y, width, height, options], props);
  return null;
};
Ellipse.displayName = 'Ellipse';
Ellipse.defaultProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};

var Line = function (props) {
  var x1 = props.x1;
  var x2 = props.x2;
  var y1 = props.y1;
  var y2 = props.y2;
  var options = props.options;
  useDrawEffect('line', [x1, y1, x2, y2, options], props);
  return null;
};
Line.displayName = 'Line';
Line.defaultProps = {
  x1: 0,
  x2: 0,
  y1: 0,
  y2: 0
};

var LinearPath = function (props) {
  useDrawEffect('linearPath', [props.points, props.options], props);
  return null;
};
LinearPath.displayName = 'LinearPath';
LinearPath.defaultProps = {
  points: []
};

var Path = function (props) {
  useDrawEffect('path', [props.d, props.options], props);
  return null;
};
Path.displayName = 'Path';
Path.defaultProps = {
  d: ''
};

var Polygon = function (props) {
  useDrawEffect('polygon', [props.vertices, props.options], props);
  return null;
};
Polygon.displayName = 'Polygon';
Polygon.defaultProps = {
  vertices: []
};

var Rectangle = function (props) {
  var x = props.x;
  var y = props.y;
  var width = props.width;
  var height = props.height;
  var options = props.options;
  useDrawEffect('rectangle', [x, y, width, height, options], props);
  return null;
};
Rectangle.displayName = 'Rectangle';
Rectangle.defaultProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};

function objectWithoutProperties$1 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
var RoughProvider = function (props) {
  RoughProvider.displayName = 'RoughProvider';
  var Provider = Context.Provider;
  var config = props.config;
  var rest$1 = objectWithoutProperties$1( props, ["config"] );
  var rest = rest$1;
  var ref = useRef();
  var ref$1 = useState({
    root: null,
    rough: null
  });
  var value = ref$1[0];
  var setValue = ref$1[1];
  useEffect(function () {
    setValue({
      root: ref.current,
      rough: roughjs.svg(ref.current, props.config)
    });
  }, [ref.current, config]);
  return createElement(Provider, {
    value: value
  }, createElement("g", Object.assign({}, rest, {
    ref: ref
  })));
};

export { Arc, Circle, Context, Curve, Ellipse, Line, LinearPath, Path, Polygon, Rectangle, RoughProvider };
//# sourceMappingURL=index.m.js.map

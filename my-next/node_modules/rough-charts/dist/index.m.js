import { createPortal } from 'react-dom';
import { scaleBand, scaleLinear } from 'd3-scale';
import { createElement, Fragment, useState, useRef, useEffect, useContext, isValidElement, cloneElement, createContext } from 'react';
import { pie, arc, line, curveCardinal, area } from 'd3-shape';
import { Line, Rectangle, Path, Circle, RoughProvider } from 'react-roughjs';
export { Rectangle, Circle } from 'react-roughjs';

var ChartContext = createContext(null);

var isNil = function (x) { return x == null; };
var isFunction = function (x) { return typeof x === 'function'; };
var removeDuplicates = function (xs) {
  var res = {};
  xs.forEach(function (key) {
    res[key] = true;
  });
  return Object.keys(res);
};
var getBandWidth = function (scale) {
  var ticks = 'ticks' in scale ? scale.ticks() : scale.domain();

  if (ticks.length <= 1) {
    var ref = scale.range();
    var low = ref[0];
    var high = ref[1];
    return Math.abs(high - low);
  }

  return Math.abs(scale(ticks[1]) - scale(ticks[0]));
};
var processTooltipHandlers = function (child, handlers) {
  if (!isValidElement(child)) {
    return null;
  }

  var additionalProps = Object.entries(handlers).reduce(function (acc, ref) {
    var handlerName = ref[0];
    var f = ref[1];

    if (child.props[handlerName]) {
      acc[handlerName] = function (e) {
        f(e);
        child.props[handlerName](e);
      };
    } else {
      acc[handlerName] = f;
    }

    return acc;
  }, {});
  return cloneElement(child, additionalProps);
};

var getDomain = function (type, values) {
  var min = Math.min.apply(Math, values);
  return type === 'scaleBand' ? values : [min > 0 ? 0 : min, Math.max.apply(Math, values)];
};

function useChartContext(props, scaleKeyName) {
  var value = useContext(ChartContext);

  if (value === null) {
    throw Error('Chart Components must be wrapped inside <ChartProvider>!');
  }

  var data = value.data;
  var contentWidth = value.contentWidth;
  var contentHeight = value.contentHeight;
  var setScaleData = value.setScaleData;
  var scaleData = value.scaleData;
  var userXScale = scaleData.userXScale;
  var userYScale = scaleData.userYScale;
  var internalXScale = scaleData.internalXScale;
  var internalYScale = scaleData.internalYScale;
  var dataKey = props.dataKey;
  useEffect(function () {
    if (!scaleKeyName) {
      return;
    }

    if (scaleKeyName === 'xDataKey') {
      if (userXScale) {
        userXScale.range([0, contentWidth]);
        setScaleData(function (prev) { return (Object.assign({}, prev,
          {xScale: userXScale,
          xDataKey: dataKey})); });
        return;
      }

      var values = data.map(function (d) { return d[dataKey]; });
      internalXScale.range([0, contentWidth]);
      var domain = getDomain('scaleBand', values);
      internalXScale.domain(domain);
      setScaleData(function (prev) {
        var obj;

        return (Object.assign({}, prev,
        ( obj = {}, obj[scaleKeyName] = dataKey, obj ),
        {xScale: internalXScale}));
      });
    }

    if (scaleKeyName === 'yDataKey' && dataKey) {
      if (userYScale) {
        userYScale.range([0, contentHeight]);
        setScaleData(function (prev) { return (Object.assign({}, prev,
          {yScale: userYScale,
          yDataKey: dataKey})); });
      } else {
        var values$1 = data.map(function (d) { return d[dataKey]; });
        internalYScale.range([0, contentHeight]);
        var domain$1 = getDomain('scaleLinear', values$1);
        internalYScale.domain(domain$1);
        setScaleData(function (prev) {
          var obj;

          return (Object.assign({}, prev,
          ( obj = {}, obj[scaleKeyName] = dataKey, obj ),
          {yScale: internalYScale}));
        });
      }
    }

    var getSeriesScaleData = function (prev) {
      var obj;

      var yDataKey = prev.yDataKey;
      var prevDataKeys = prev[scaleKeyName];
      var newDataKeys = prevDataKeys.indexOf(dataKey) > -1 ? prevDataKeys : prevDataKeys.concat( [dataKey]);
      var newScaleData = Object.assign({}, prev,
        ( obj = {}, obj[scaleKeyName] = newDataKeys, obj ));
      var barDataKeys = newScaleData.barDataKeys;
      var lineDataKeys = newScaleData.lineDataKeys;
      var circleDataKeys = newScaleData.circleDataKeys;
      var areaDataKeys = newScaleData.areaDataKeys; // TODO xScale

      if (userYScale) {
        userYScale.range([contentHeight, 0]);
        newScaleData.yScale = userYScale;
      } else {
        var noneStackedValues = removeDuplicates(lineDataKeys.concat( barDataKeys, circleDataKeys)).reduce(function (acc, groupName) {
          acc.push.apply(acc, data.map(function (item) { return +item[groupName]; }));
          return acc;
        }, []);
        var areaValues = data.map(function (d) { return areaDataKeys.reduce(function (sum, key) { return sum + d[key]; }, 0); });
        var values = yDataKey ? data.map(function (d) { return d[yDataKey]; }) : noneStackedValues.concat( areaValues);
        var domain = getDomain('scaleLinear', values);
        internalYScale.domain(domain);
        internalYScale.range([contentHeight, 0]);
        newScaleData.yScale = internalYScale;
      }

      return newScaleData;
    };

    if (scaleKeyName === 'barDataKeys') {
      setScaleData(function (prev) {
        var newScaleData = getSeriesScaleData(prev);
        var barScale = scaleBand().domain(newScaleData[scaleKeyName]);
        newScaleData.barScale = barScale;
        return newScaleData;
      });
    }

    if (scaleKeyName === 'lineDataKeys' || scaleKeyName === 'circleDataKeys' || scaleKeyName === 'areaDataKeys') {
      setScaleData(function (prev) { return getSeriesScaleData(prev); });
    }
  }, [scaleKeyName, dataKey, contentHeight, contentWidth]);
  var margin = Object.assign({}, value.margin);
  var width = value.width;
  var height = value.height;
  return Object.assign({}, value,
    {width: width,
    height: height,
    contentWidth: width - margin.left - margin.right,
    contentHeight: height - margin.top - margin.bottom,
    options: Object.assign({}, value.options,
      (props.options || {})),
    margin: margin,
    data: !isNil(props.data) ? props.data : value.data,
    scaleData: value.scaleData,
    setScaleData: value.setScaleData});
}

/* eslint-disable react/no-array-index-key */
var XAxis = function (props) {
  if (!props.dataKey) {
    throw Error('dataKey of XAxisProps is required');
  }

  var ref = useChartContext(props, 'xDataKey');
  var options = ref.options;
  var contentHeight = ref.contentHeight;
  var contentWidth = ref.contentWidth;
  var scaleData = ref.scaleData;
  var xScale = scaleData.xScale;
  var tickSize = props.tickSize;
  var fontSize = props.fontSize;
  var format = props.format;
  var tickCount = props.tickCount;

  if (!xScale) {
    return null;
  }

  var ticks = 'ticks' in xScale ? xScale.ticks(tickCount) : xScale.domain();
  var bandwidth = getBandWidth(xScale);
  var y = contentHeight;
  return createElement(Fragment, null, createElement(Line, {
    x1: 0,
    y1: y,
    x2: contentWidth + bandwidth / 2,
    y2: y,
    options: Object.assign({}, {bowing: 0.2},
      options)
  }), ticks.map(function (t, index) { return createElement(Fragment, {
    key: index
  }, createElement(Line, {
    x1: xScale(t) + bandwidth / 2,
    y1: y,
    x2: xScale(t) + bandwidth / 2,
    y2: y + tickSize,
    options: Object.assign({}, {strokeWidth: 2},
      options)
  }), createElement("text", {
    x: xScale(t) + bandwidth / 2,
    y: y + tickSize + fontSize,
    stroke: options.stroke,
    fill: options.stroke,
    textAnchor: "middle"
  }, isFunction(format) ? format(t) : String(t))); }));
};
XAxis.displayName = 'XAxis';
XAxis.defaultProps = {
  tickSize: 10,
  fontSize: 16,
  tickCount: 10
};

/* eslint-disable react/no-array-index-key */
var YAxis = function (props) {
  var tickSize = props.tickSize;
  var fontSize = props.fontSize;
  var format = props.format;
  var tickCount = props.tickCount;
  var ref = useChartContext(props, 'yDataKey');
  var options = ref.options;
  var contentHeight = ref.contentHeight;
  var scaleData = ref.scaleData;
  var scale = scaleData.yScale;

  if (!scale) {
    return null;
  }

  var ticks = scale.ticks ? scale.ticks(tickCount) : scale.domain();
  return createElement(Fragment, null, createElement(Line, {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: contentHeight,
    options: Object.assign({}, {bowing: 0.2},
      options)
  }), ticks.map(function (t, index) { return createElement(Fragment, {
    key: index
  }, createElement(Line, {
    x1: 0 - tickSize,
    x2: 0,
    y1: scale(t),
    y2: scale(t),
    options: Object.assign({}, {strokeWidth: 2},
      options)
  }), createElement("text", {
    x: 0 - tickSize,
    y: scale(t) + fontSize / 3,
    stroke: options.stroke,
    fill: options.stroke,
    textAnchor: "end"
  }, isFunction(format) ? format(t) : String(t))); }));
};
YAxis.displayName = 'YAxis';
YAxis.defaultProps = {
  tickSize: 10,
  fontSize: 16,
  tickCount: 10
};

var mousePositions = function (event) {
  var IE = !!document.all;
  var x;
  var y;

  if (IE) {
    x = event.clientX + document.body.scrollLeft;
    y = event.clientY + document.body.scrollTop;
  } else {
    x = window.Event ? event.pageX : event.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
    y = window.Event ? event.pageY : event.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
  }

  return {
    x: x,
    y: y
  };
};

var useTooltipGenerator = function (props) {
  var dataKey = props.dataKey;

  if (!dataKey) {
    throw Error('dataKey is Required!');
  }

  var ref = useChartContext(props);
  var setTooltipData = ref.setTooltipData;

  var generateHandlers = function (item, content) {
    if ( content === void 0 ) content = {
    name: '',
    value: ''
  };

    return ({
    onMouseOver: function (e) {
      var ref = mousePositions(e);
      var x = ref.x;
      var y = ref.y;
      setTooltipData(function (prev) { return (Object.assign({}, prev,
        {showToolTip: true,
        x: x,
        y: y,
        name: content.name,
        value: content.value,
        activeItem: item})); });
    },
    onMouseMove: function (e) {
      var ref = mousePositions(e);
      var x = ref.x;
      var y = ref.y;
      setTooltipData(function (prev) { return (Object.assign({}, prev,
        {showToolTip: true,
        x: x,
        y: y,
        activeItem: item})); });
    },
    onMouseOut: function () {
      setTooltipData(function (prev) { return (Object.assign({}, prev,
        {showToolTip: false})); });
    }
  });
  };

  return {
    generateHandlers: generateHandlers
  };
};

/* eslint-disable react/no-array-index-key */
var BarSeries = function (props) {
  var dataKey = props.dataKey;
  var options = props.options;
  var ref = useChartContext(props, 'barDataKeys');
  var data = ref.data;
  var contentHeight = ref.contentHeight;
  var scaleData = ref.scaleData;
  var xScale = scaleData.xScale;
  var barScale = scaleData.barScale;
  var yScale = scaleData.yScale;
  var xDataKey = scaleData.xDataKey;
  var ref$1 = useTooltipGenerator(props);
  var generateHandlers = ref$1.generateHandlers;

  if (!dataKey) {
    throw Error('dataKey is Required!');
  } // TODO xDataKey


  if (!xScale || !barScale || !yScale || !xDataKey) {
    return null;
  }

  var width = getBandWidth(xScale);
  var offset = width * 0.2 / 2;

  var generateChildProps = function (item) {
    var x = xScale(item[xDataKey]);
    barScale.range([x + offset, x + width - offset]);
    var min = yScale.domain()[0];
    var y0 = yScale(0);
    var itemY = yScale(item[dataKey]);
    var y = min >= 0 ? itemY : yScale(Math.max(item[dataKey], 0));
    var height = min >= 0 ? contentHeight - itemY : Math.abs(y0 - itemY);
    return {
      x: barScale(dataKey),
      y: y,
      width: barScale.bandwidth(),
      height: height,
      options: Object.assign({}, {fill: 'black'},
        options)
    };
  };

  var children = props.children;
  return createElement(Fragment, null, data.map(function (item, index) {
    var handlers = generateHandlers(item, {
      name: ("" + dataKey),
      value: ("" + (item[dataKey]))
    });
    var childProps = generateChildProps(item);
    return isFunction(children) ? processTooltipHandlers(children(item, childProps, index), handlers) : createElement(Rectangle, Object.assign({
      key: index
    }, childProps, handlers));
  }));
};
BarSeries.displayName = 'BarSeries';

function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
var Arc = function (props) {
  var innerRadius = props.innerRadius;
  var outerRadius = props.outerRadius;
  var startAngle = props.startAngle;
  var endAngle = props.endAngle;
  var padAngle = props.padAngle;
  var options = props.options;
  var cx = props.cx;
  var cy = props.cy;
  var rest$1 = objectWithoutProperties( props, ["innerRadius", "outerRadius", "startAngle", "endAngle", "padAngle", "options", "cx", "cy"] );
  var rest = rest$1;
  var a = arc();
  var d = a({
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    startAngle: startAngle,
    endAngle: endAngle,
    padAngle: padAngle
  });
  return createElement(Path, Object.assign({
    d: d,
    transform: ("translate(" + cx + ", " + cy + ")"),
    options: options
  }, rest));
};
Arc.displayName = 'RcArc';
Arc.defaultProps = {
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0
};

/* eslint-disable react/no-array-index-key */
var ArcSeries = function (props) {
  var ref = useChartContext(props);
  var data = ref.data;
  var options = ref.options;
  var contentHeight = ref.contentHeight;
  var contentWidth = ref.contentWidth;
  var ref$1 = useTooltipGenerator(props);
  var generateHandlers = ref$1.generateHandlers;
  var dataKey = props.dataKey;
  var cx = props.cx;
  var cy = props.cy;
  var innerRadiusPercent = props.innerRadiusPercent;
  var outerRadiusPercent = props.outerRadiusPercent;
  var padAngleProp = props.padAngle;
  var startAngleProp = props.startAngle;
  var endAngleProp = props.endAngle;
  var children = props.children;
  var newCx = !isNil(cx) ? cx : contentWidth / 2;
  var newCy = !isNil(cy) ? cy : contentHeight / 2;
  var radius = Math.min(newCx, newCy);
  var arcs = pie().startAngle(startAngleProp).padAngle(padAngleProp).endAngle(endAngleProp)(data.map(function (d) { return d[dataKey]; }));
  var arcsData = arcs.map(function (arc$$1) {
    var startAngle = arc$$1.startAngle;
    var endAngle = arc$$1.endAngle;
    var padAngle = arc$$1.padAngle;
    return {
      innerRadius: radius * innerRadiusPercent,
      outerRadius: radius * outerRadiusPercent,
      startAngle: startAngle,
      endAngle: endAngle,
      padAngle: padAngle
    };
  });
  var total = data.reduce(function (acc, d) { return acc + d[dataKey]; }, 0);
  return createElement(Fragment, null, arcsData.map(function (arcProps, index) {
    var item = data[index];
    var percent = (item[dataKey] / total * 100).toPrecision(3);
    var handlers = generateHandlers(item, {
      name: (dataKey + " " + (item[dataKey])),
      value: (percent + "%")
    });
    var childProps = Object.assign({}, arcProps,
      {cx: newCx,
      cy: newCy,
      options: Object.assign({}, {fill: 'black'},
        options)});

    if (isFunction(children)) {
      return processTooltipHandlers(children(item, childProps, index), handlers);
    }

    return createElement(Arc, Object.assign({
      key: index
    }, childProps, handlers));
  }));
};
ArcSeries.displayName = 'ArcSeries';
ArcSeries.defaultProps = {
  innerRadiusPercent: 0,
  outerRadiusPercent: 1,
  padAngle: 0,
  startAngle: 0,
  endAngle: Math.PI * 2
};

var Y0 = function (props) {
  var ref = useChartContext(props);
  var yScale = ref.scaleData.yScale;
  var contentWidth = ref.contentWidth;

  if (!yScale) {
    return null;
  }

  return createElement(Line, {
    y1: yScale(0),
    y2: yScale(0),
    x1: 0,
    x2: contentWidth,
    strokeDasharray: "30",
    options: Object.assign({}, {bowing: 0.2},
      props.options)
  });
};
Y0.displayName = 'Y0';

/* eslint-disable react/no-array-index-key */
var CircleSeries = function (props) {
  var ref = useChartContext(props, 'circleDataKeys');
  var scaleData = ref.scaleData;
  var data = ref.data;
  var options = ref.options;
  var xScale = scaleData.xScale;
  var yScale = scaleData.yScale;
  var xDataKey = scaleData.xDataKey;
  var dataKey = props.dataKey;
  var ref$1 = useTooltipGenerator(props);
  var generateHandlers = ref$1.generateHandlers;

  if (!xScale || !yScale || !dataKey || !xDataKey) {
    return null;
  }

  var bandwidth = getBandWidth(xScale);
  var points = data.map(function (item) { return [xScale(item[xDataKey]), yScale(item[dataKey])]; });
  var children = props.children;
  return createElement(Fragment, null, points.map(function (ref, index) {
    var x = ref[0];
    var y = ref[1];

    var childProps = {
      x: x + bandwidth / 2,
      y: y,
      diameter: 10,
      options: Object.assign({}, options)
    };
    var item = data[index];
    var handlers = generateHandlers(data[index], {
      name: ((item[xDataKey]) + " " + dataKey),
      value: ("" + (item[dataKey]))
    });

    if (isFunction(children)) {
      return processTooltipHandlers(children(data[index], childProps, index), handlers);
    }

    return createElement(Circle, Object.assign({
      key: index
    }, childProps, handlers));
  }));
};
CircleSeries.displayName = 'CircleSeries';

/* eslint-disable react/no-array-index-key */
var LineSeries = function (props) {
  var ref = useChartContext(props, 'lineDataKeys');
  var scaleData = ref.scaleData;
  var data = ref.data;
  var options = ref.options;
  var xScale = scaleData.xScale;
  var yScale = scaleData.yScale;
  var xDataKey = scaleData.xDataKey;
  var dataKey = props.dataKey;
  var curve = props.curve;

  if (!xScale || !yScale || !dataKey || !xDataKey) {
    return null;
  }

  var bandwidth = getBandWidth(xScale);
  var points = data.map(function (item) { return [xScale(item[xDataKey]), yScale(item[dataKey])]; });
  var line$$1 = line().curve(curve);
  var path = line$$1(points);
  return createElement(Fragment, null, createElement(Path, {
    transform: ("translate(" + (bandwidth / 2) + ", 0)"),
    d: path,
    options: options
  }), createElement(CircleSeries, Object.assign({}, props)));
};
LineSeries.displayName = 'LineSeries';
LineSeries.defaultProps = {
  curve: curveCardinal.tension(0.5)
};

var Tooltip = function (props) {
  var ref = useChartContext(props);
  var tooltipData = ref.tooltipData;
  var setTooltipData = ref.setTooltipData;
  var contentWidth = ref.contentWidth;
  var options = ref.options;
  var x = tooltipData.x;
  var y = tooltipData.y;
  var showToolTip = tooltipData.showToolTip;
  var name = tooltipData.name;
  var value = tooltipData.value;
  var activeItem = tooltipData.activeItem;
  var propsWidth = props.width;
  var height = props.height;
  var fontSize = props.fontSize;
  var children = props.children;
  var ref$1 = useState(120);
  var internalWidth = ref$1[0];
  var setWidth = ref$1[1];
  var textRef = useRef();
  var width = isNil(propsWidth) ? internalWidth : propsWidth;
  useEffect(function () {
    var node = textRef.current;

    if (node) {
      var ref = node.getBBox();
      var textWidth = ref.width;
      setWidth(textWidth + 30);
    }
  }, [textRef.current]);

  if (!showToolTip || !activeItem) {
    return null;
  } // TODO pintX pointY


  var left = contentWidth - x < width + 20 ? x - 20 - width : x + 20;

  var ellipse = function (s, length) {
    if ( s === void 0 ) s = '';

    return s.length > length ? ((s.slice(0, length)) + "...") : s;
  };

  var renderChildren = function () {
    var text = function (s) { return createElement("text", {
      ref: textRef,
      textAnchor: "middle",
      stroke: "black",
      fill: "black",
      x: width / 2,
      y: height / 2 + fontSize / 3
    }, s); };

    if (isFunction(children)) {
      var content = children(activeItem);
      return typeof content === 'string' ? text(content) : content;
    }

    return text(((ellipse(name, 20)) + ": " + (ellipse(value, 5))));
  };

  var content = createElement("div", {
    style: {
      position: 'absolute',
      left: left,
      top: y - height / 2
    }
  }, createElement("svg", {
    width: width + 4,
    height: height + 4
  }, createElement("g", {
    transform: "translate(2, 2)"
  }, createElement(RoughProvider, null, createElement(Rectangle, {
    width: width,
    height: height,
    onMouseOver: function (e) {
      setTooltipData(function (prev) { return (Object.assign({}, prev,
        {x: e.clientX,
        y: e.clientY})); });
    },
    onMouseMove: function (e) {
      setTooltipData(function (prev) { return (Object.assign({}, prev,
        {x: e.clientX,
        y: e.clientY})); });
    },
    onMouseOut: function () {
      setTooltipData(function (prev) { return (Object.assign({}, prev,
        {showToolTip: false})); });
    },
    options: Object.assign({}, {fill: 'white',
      fillStyle: 'solid',
      strokeWidth: 2},
      options)
  })), createElement(RoughProvider, null, renderChildren()))));
  return createPortal(content, document.body);
};
Tooltip.displayName = 'Tooltip';
Tooltip.defaultProps = {
  height: 40,
  fontSize: 16
};

var Provider = ChartContext.Provider;
var defaultMargin = {
  top: 10,
  right: 10,
  bottom: 50,
  left: 50
};
var ChartProvider = function (props) {
  var ref$1 = useState(0);
  var innerHeight = ref$1[0];
  var setInnerHeight = ref$1[1];
  var ref$2 = useState(0);
  var innerWidth = ref$2[0];
  var setInnerWidth = ref$2[1];
  var ref = useRef();
  var internalXScale = scaleBand();
  var internalYScale = scaleLinear();
  var ref$3 = useState({
    barDataKeys: [],
    lineDataKeys: [],
    circleDataKeys: [],
    areaDataKeys: [],
    xScale: props.xScale || internalXScale,
    yScale: props.yScale || internalYScale,
    userXScale: props.xScale,
    userYScale: props.yScale,
    internalXScale: internalXScale,
    internalYScale: internalYScale
  });
  var scaleData = ref$3[0];
  var setScaleData = ref$3[1];
  var ref$4 = useState({
    x: -1,
    y: -1,
    showToolTip: false,
    name: '',
    value: '',
    activeItem: null
  });
  var tooltipData = ref$4[0];
  var setTooltipData = ref$4[1];
  useEffect(function () {
    var handleResize = function () {
      if (ref.current && (isNil(props.height) || isNil(props.width))) {
        var boundingRect = ref.current.parentElement.getBoundingClientRect();
        setInnerHeight(boundingRect.height);
        setInnerWidth(boundingRect.width);
      }
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    return function () { return window.removeEventListener('resize', handleResize); };
  }, [props.height, props.width, ref.current]);
  var height = !isNil(props.height) ? props.height : innerHeight;
  var width = !isNil(props.width) ? props.width : innerWidth;
  var propsMargin = props.margin;
  var margin = Object.assign({}, defaultMargin,
    propsMargin);

  var shouldRenderChildren = function () { return height && width; };

  return createElement(Provider, {
    value: Object.assign({}, props,
      {height: height,
      width: width,
      margin: margin,
      scaleData: scaleData,
      setScaleData: function (f) { return setScaleData(f); },
      contentHeight: height - margin.bottom - margin.top,
      contentWidth: width - margin.left - margin.right,
      tooltipData: tooltipData,
      setTooltipData: function (f) { return setTooltipData(f); }})
  }, createElement("svg", {
    height: height,
    width: width,
    ref: ref
  }, createElement(RoughProvider, {
    transform: ("translate(" + (margin.left) + ", " + (margin.top) + ")"),
    config: {
      options: props.options
    }
  }, shouldRenderChildren() && props.children)));
};
ChartProvider.displayName = 'ChartProvider';
ChartProvider.defaultProps = {
  data: [],
  options: {},
  margin: defaultMargin
};

/* eslint-disable react/no-array-index-key */
var AreaSeries = function (props) {
  var ref = useChartContext(props, 'areaDataKeys');
  var scaleData = ref.scaleData;
  var data = ref.data;
  var options = ref.options;
  var xScale = scaleData.xScale;
  var yScale = scaleData.yScale;
  var xDataKey = scaleData.xDataKey;
  var areaDataKeys = scaleData.areaDataKeys;
  var dataKey = props.dataKey;
  var curve = props.curve;
  var children = props.children;
  var padding = props.padding;
  var ref$1 = useTooltipGenerator(props);
  var generateHandlers = ref$1.generateHandlers;

  if (!xScale || !yScale || !dataKey || !xDataKey) {
    return null;
  }

  var areaKeyIndex = areaDataKeys.indexOf(dataKey);

  var calculateY = function (d) {
    if (areaKeyIndex === 0) {
      return {
        y0: yScale(yScale.domain()[0]),
        y1: yScale(d[dataKey])
      };
    }

    var sum = function (keys) {
      if ( keys === void 0 ) keys = [];

      return keys.reduce(function (acc, key) { return acc + d[key]; }, 0);
    };

    return {
      y0: yScale(sum(areaDataKeys.slice(0, areaKeyIndex))) - padding,
      y1: yScale(sum(areaDataKeys.slice(0, areaKeyIndex + 1)))
    };
  };

  var bandwidth = getBandWidth(xScale);
  var positions = data.map(function (item) {
    var ref = calculateY(item);
    var y0 = ref.y0;
    var y1 = ref.y1;
    return {
      x: xScale(item[xDataKey]),
      y0: y0,
      y1: y1
    };
  });
  var area$$1 = area().x(function (d) { return d.x; }).y1(function (d) { return d.y1; }).y0(function (d) { return d.y0; }).curve(curve);
  var areaPath = area$$1(positions);
  return createElement(Fragment, null, createElement(Path, {
    transform: ("translate(" + (bandwidth / 2) + ", 0)"),
    d: areaPath,
    options: Object.assign({}, {fill: options.stroke},
      options)
  }), positions.map(function (ref, index) {
    var x = ref.x;
    var y1 = ref.y1;

    var childProps = {
      x: x + bandwidth / 2,
      y: y1,
      diameter: 12,
      options: {
        fill: options.fill || options.stroke,
        strokeWidth: 2,
        fillStyle: 'solid',
        stroke: 'white'
      }
    };
    var item = data[index];
    var handlers = generateHandlers(data[index], {
      name: ((item[xDataKey]) + " " + dataKey),
      value: ("" + (item[dataKey]))
    });

    if (isFunction(children)) {
      return processTooltipHandlers(children(data[index], childProps, index), handlers);
    }

    return createElement(Circle, Object.assign({
      key: index
    }, childProps, handlers));
  }));
};
AreaSeries.displayName = 'LineSeries';
AreaSeries.defaultProps = {
  curve: curveCardinal.tension(0.5),
  padding: 6
};

export { XAxis, YAxis, BarSeries, ArcSeries, Arc, Y0, LineSeries, CircleSeries, Tooltip, ChartProvider, AreaSeries };
//# sourceMappingURL=index.m.js.map
